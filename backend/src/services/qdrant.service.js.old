/**
 * Service de gestion de Qdrant (Vector Database)
 */
const { QdrantClient } = require('@qdrant/js-client-rest');
const logger = require('../utils/logger');
const config = require('../config/config');
const { QdrantError } = require('../utils/errors');

class QdrantService {
  constructor() {
    this.client = new QdrantClient({ url: config.qdrant.url });
    this.collectionName = config.qdrant.collectionName;
    this.vectorSize = config.embedding.dimension;
  }

  /**
   * Initialise la collection Qdrant
   */
  async initializeCollection() {
    try {
      // Vérifier si la collection existe
      const collections = await this.client.getCollections();
      const exists = collections.collections.some(
        c => c.name === this.collectionName
      );

      if (!exists) {
        logger.info(`Création de la collection: ${this.collectionName}`);
        await this.client.createCollection(this.collectionName, {
          vectors: {
            size: this.vectorSize,
            distance: 'Cosine',
          },
          optimizers_config: {
            default_segment_number: 2,
          },
          replication_factor: 1,
        });
        logger.info('Collection créée avec succès');
      } else {
        logger.info(`Collection ${this.collectionName} déjà existante`);
      }
    } catch (error) {
      logger.error('Erreur lors de l\'initialisation de Qdrant', error);
      throw new QdrantError(`Erreur Qdrant init: ${error.message}`);
    }
  }

  /**
   * Ajoute des points (vecteurs) à la collection
   * @param {Array} points - Tableau de {id, vector, payload}
   */
  async upsertPoints(points) {
    try {
      await this.client.upsert(this.collectionName, {
        wait: true,
        points: points.map(p => ({
          id: p.id,
          vector: p.vector,
          payload: p.payload,
        })),
      });

      logger.info(`${points.length} points ajoutés à Qdrant`);
    } catch (error) {
      logger.error('Erreur lors de l\'ajout de points à Qdrant', error);
      throw new QdrantError(`Erreur upsert: ${error.message}`);
    }
  }

  /**
   * Recherche les vecteurs les plus similaires
   * @param {number[]} queryVector - Vecteur de requête
   * @param {number} limit - Nombre de résultats
   * @returns {Promise<Array>} Résultats de recherche
   */
  async search(queryVector, limit = config.rag.topKResults) {
    try {
      const searchResult = await this.client.search(this.collectionName, {
        vector: queryVector,
        limit,
        with_payload: true,
        with_vector: false,
      });

      logger.info(`Recherche Qdrant: ${searchResult.length} résultats trouvés`);
      return searchResult;
    } catch (error) {
      logger.error('Erreur lors de la recherche dans Qdrant', error);
      throw new QdrantError(`Erreur search: ${error.message}`);
    }
  }

  /**
   * Compte le nombre de points dans la collection
   */
  async countPoints() {
    try {
      const result = await this.client.count(this.collectionName);
      return result.count;
    } catch (error) {
      logger.error('Erreur lors du comptage des points', error);
      return 0;
    }
  }

  /**
   * Supprime tous les points de la collection
   */
  async clearCollection() {
    try {
      await this.client.deleteCollection(this.collectionName);
      await this.initializeCollection();
      logger.info('Collection vidée et réinitialisée');
    } catch (error) {
      logger.error('Erreur lors du nettoyage de la collection', error);
      throw new QdrantError(`Erreur clear: ${error.message}`);
    }
  }

  /**
   * Vérifie la santé de Qdrant
   */
  async healthCheck() {
    try {
      await this.client.getCollections();
      return true;
    } catch (error) {
      logger.error('Qdrant health check failed', error);
      return false;
    }
  }
}

// Instance singleton
const qdrantService = new QdrantService();
module.exports = qdrantService;
